import { Component, OnInit, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ResourceCardComponent } from './components/resource-card/resource-card.component';
import { ResourceService } from './services/resource.service';
import { SearchService } from './services/search.service';
import { TranslateService } from './services/translate.service';
import {
  ResourceItem,
  ResourceCategory,
  ResourceType,
  Language,
  SearchResultGroup,
  AIState,
} from './models/types';

type SortOption = 'newest' | 'oldest' | 'az' | 'popular';

interface ViewGroup {
  title: string;
  description: string;
  resources: ResourceItem[];
}

@Component({
  selector: 'app-root',
  imports: [CommonModule, FormsModule, ResourceCardComponent],
  templateUrl: './app.html',
  styleUrl: './app.css',
  standalone: true,
})
export class App implements OnInit {
  // Expose enums to template
  ResourceCategory = ResourceCategory;
  ResourceType = ResourceType;

  // Core Data State
  displayResources = signal<ResourceItem[]>([]);
  language = signal<Language>('en');

  // Search & Filter State
  searchQuery = signal('');
  isSemanticMode = signal(false);
  semanticGroups = signal<SearchResultGroup[] | null>(null);

  selectedTopic = signal<ResourceCategory | 'All'>('All' as any);
  selectedType = signal<ResourceType | 'All'>('All' as any);
  sortOrder = signal<SortOption>('newest');

  // UI State
  isLangMenuOpen = signal(false);

  // Popularity State
  popularIds = signal(new Set<string>());

  // AI Loading States
  aiState = signal<AIState>({
    isTranslating: false,
    isSearching: false,
    error: null,
  });

  // Translation Cache
  private translationCache = new Map<string, ResourceItem[]>();

  // Computed: Filtered Resources
  filteredResources = computed(() => {
    let result = [...this.displayResources()];
    const topic = this.selectedTopic();
    const type = this.selectedType();
    const query = this.searchQuery();
    const semantic = this.isSemanticMode();
    const sort = this.sortOrder();

    // Filter by category
    if (topic !== 'All') {
      result = result.filter((r) => r.category === topic);
    }

    // Filter by type
    if (type !== 'All') {
      result = result.filter((r) => r.type === type);
    }

    // Keyword search (not in semantic mode)
    if (query && !semantic) {
      const q = query.toLowerCase();
      result = result.filter(
        (r) => r.title.toLowerCase().includes(q) || r.description.toLowerCase().includes(q)
      );
    }

    // Sort
    result.sort((a, b) => {
      switch (sort) {
        case 'newest':
          return new Date(b.date).getTime() - new Date(a.date).getTime();
        case 'oldest':
          return new Date(a.date).getTime() - new Date(b.date).getTime();
        case 'az':
          return a.title.localeCompare(b.title);
        case 'popular':
          const aClicks = this.popularIds().has(a.id) ? 1 : 0;
          const bClicks = this.popularIds().has(b.id) ? 1 : 0;
          return bClicks - aClicks;
        default:
          return 0;
      }
    });

    return result;
  });

  // Computed: View Groups
  viewGroups = computed<ViewGroup[]>(() => {
    const semantic = this.isSemanticMode();
    const groups = this.semanticGroups();
    const query = this.searchQuery();
    const topic = this.selectedTopic();
    const filtered = this.filteredResources();
    const resources = this.displayResources();

    // Semantic mode with results
    if (semantic && groups) {
      return groups
        .map((group) => ({
          title: group.title,
          description: group.description,
          resources: group.resourceIds
            .map((id) => resources.find((r) => r.id === id))
            .filter(Boolean) as ResourceItem[],
        }))
        .filter((g) => g.resources.length > 0);
    }

    // Search results
    if (query && !semantic) {
      return [
        {
          title: 'Search Results',
          description: `Found ${filtered.length} matches for "${query}"`,
          resources: filtered,
        },
      ];
    }

    // Category filter
    if (topic !== 'All') {
      return [
        {
          title: topic,
          description: 'Resources in this category',
          resources: filtered,
        },
      ];
    }

    // Default: Group by category
    const categories = Object.values(ResourceCategory).filter((c) => c !== ResourceCategory.ALL);
    return categories
      .map((cat) => {
        const resourcesInCat = filtered.filter((r) => r.category === cat);
        return {
          title: cat,
          description: this.getCategoryDescription(cat),
          resources: resourcesInCat,
        };
      })
      .filter((g) => g.resources.length > 0);
  });

  // Get all topics for template
  topics = Object.values(ResourceCategory);

  // Get all types for template (excluding ALL)
  types = Object.values(ResourceType).filter((t) => t !== ResourceType.ALL);

  constructor(
    private resourceService: ResourceService,
    private searchService: SearchService,
    private translateService: TranslateService
  ) {
    // Cache English resources
    this.translationCache.set('en', []);
  }

  ngOnInit() {
    this.loadResources();
    this.loadPopularResources();
  }

  private loadResources() {
    this.resourceService.getResources().subscribe({
      next: (resources) => {
        this.displayResources.set(resources);
        this.translationCache.set('en', resources);
      },
      error: (err) => console.error('Failed to load resources:', err),
    });
  }

  private loadPopularResources() {
    this.resourceService.getPopularResources().subscribe({
      next: (ids) => {
        this.popularIds.set(new Set(ids));
      },
      error: (err) => console.error('Failed to load popular resources:', err),
    });
  }

  handleLanguageChange(lang: Language) {
    this.isLangMenuOpen.set(false);
    if (lang === this.language()) return;
    this.language.set(lang);

    // Check cache first
    const cached = this.translationCache.get(lang);
    if (cached) {
      this.displayResources.set(cached);
      return;
    }

    // Translate using AI
    this.aiState.update((state) => ({ ...state, isTranslating: true }));
    const originalResources = this.translationCache.get('en') || [];

    this.translateService.translateResources(originalResources, lang).subscribe({
      next: (translated) => {
        this.translationCache.set(lang, translated);
        this.displayResources.set(translated);
        this.aiState.update((state) => ({ ...state, isTranslating: false }));
      },
      error: (err) => {
        console.error('Translation failed:', err);
        this.aiState.update((state) => ({ ...state, isTranslating: false }));
      },
    });
  }

  handleSemanticSearch() {
    const query = this.searchQuery();
    if (!query.trim()) return;

    this.aiState.update((state) => ({ ...state, isSearching: true, error: null }));

    this.searchService.performSemanticSearch(query).subscribe({
      next: (groups) => {
        this.semanticGroups.set(groups);
        this.aiState.update((state) => ({ ...state, isSearching: false }));
      },
      error: (err) => {
        console.error('Semantic search failed:', err);
        this.aiState.update((state) => ({
          ...state,
          isSearching: false,
          error: 'AI Search failed. Try again.',
        }));
      },
    });
  }

  handleResourceInteract(id: string) {
    this.resourceService.trackInteraction(id).subscribe({
      next: () => {
        // Reload popular resources after interaction
        this.loadPopularResources();
      },
      error: (err) => console.error('Failed to track interaction:', err),
    });
  }

  toggleSemanticMode(isOn: boolean) {
    this.isSemanticMode.set(isOn);
    if (!isOn) {
      this.semanticGroups.set(null);
    }
  }

  resetFilters() {
    this.searchQuery.set('');
    this.selectedTopic.set('All' as any);
    this.selectedType.set('All' as any);
    this.semanticGroups.set(null);
  }

  onSearchKeyDown(event: KeyboardEvent) {
    if (event.key === 'Enter' && this.isSemanticMode()) {
      this.handleSemanticSearch();
    }
  }

  private getCategoryDescription(cat: ResourceCategory): string {
    switch (cat) {
      case ResourceCategory.OC4IDS:
        return 'Standards, tools, and documentation for the Open Contracting for Infrastructure Data Standard.';
      case ResourceCategory.ASSURANCE:
        return 'Manuals and guides for conducting independent assurance and validation of projects.';
      case ResourceCategory.INDEX:
        return 'Methodologies and calculation tools for the Infrastructure Transparency Index.';
      case ResourceCategory.GUIDANCE:
        return 'Best practices and detailed guidance notes for implementation and policy.';
      default:
        return 'Resources';
    }
  }
}
