import { Router } from 'express';
import { ComposeRequest } from '../types.js';
import { generatePDFBuffer } from '../services/pdfGenerator.js';

export const compose = Router();

/**
 * POST /compose
 *
 * Generates formatted export document from selected items and answer bullets
 *
 * Request body:
 * {
 *   items: string[],              // Document IDs
 *   bullets: AnswerBullet[],      // Answer bullets with citations
 *   format: 'brief' | 'pack' | 'notes'
 * }
 *
 * Response:
 * {
 *   markdown: string,             // Formatted Markdown document
 *   title: string                 // Suggested filename
 * }
 *
 * Formats:
 * - brief: Executive summary (bullets + key sources)
 * - pack: Full reading pack (bullets + full item details)
 * - notes: Meeting notes format (concise, action-oriented)
 */
compose.post('/', async (req, res, next) => {
  try {
    const body = req.body as Partial<ComposeRequest> & Record<string, unknown>;
    const rawItems = body?.items;
    const items = Array.isArray(rawItems)
      ? rawItems.filter((id): id is string => typeof id === 'string' && id.trim().length > 0)
      : typeof rawItems === 'string'
        ? [rawItems]
        : [];

    const rawBullets = body?.bullets;
    const bullets = Array.isArray(rawBullets)
      ? rawBullets.filter(
        (bullet): bullet is ComposeRequest['bullets'][number] =>
          Boolean(bullet && typeof bullet.text === 'string' && Array.isArray(bullet.cites))
      )
      : [];

    const allowedFormats = new Set<ComposeRequest['format']>(['brief', 'pack', 'notes']);
    const rawFormat = typeof body.format === 'string' ? body.format : undefined;
    const format = rawFormat && allowedFormats.has(rawFormat as ComposeRequest['format'])
      ? rawFormat as ComposeRequest['format']
      : 'brief';

    if (items.length === 0 || bullets.length === 0) {
      return res.status(400).json({
        error: 'Missing required fields: items, bullets'
      });
    }

    const timestamp = new Date().toISOString().split('T')[0];
    let markdown = '';

    // Header
    markdown += `# CoST Knowledge Hub Export\n`;
    markdown += `**Generated:** ${timestamp}\n`;
    markdown += `**Format:** ${format}\n\n`;

    // Answer section
    markdown += `## Answer\n\n`;
    bullets.forEach((bullet, i) => {
      markdown += `${i + 1}. ${bullet.text}\n`;
      bullet.cites.forEach(cite => {
        markdown += `   - [${cite.title}](${cite.url})\n`;
      });
      markdown += `\n`;
    });

    // Sources section
    markdown += `## Selected Sources\n\n`;
    markdown += `${items.length} item(s) selected\n\n`;

    // Format-specific content
    if (format === 'brief') {
      markdown += `*This brief includes only the answer synthesis and citation links.*\n`;
    } else if (format === 'pack') {
      markdown += `*Full reading pack with detailed item information.*\n`;
      // In production, you'd fetch full details for each item ID
      markdown += `\nNote: Full item details would be fetched from database in production.\n`;
    } else if (format === 'notes') {
      markdown += `*Meeting-ready notes with action items.*\n`;
      markdown += `\n### Action Items\n`;
      markdown += `- Review cited sources\n`;
      markdown += `- Follow up on relevant findings\n`;
    }

    // Footer
    markdown += `\n---\n`;
    markdown += `*Generated by CoST Knowledge Hub - infrastructuretransparency.org*\n`;

    const title = `CoST-Export-${format}-${timestamp}.md`;

    res.json({ markdown, title });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /compose/pdf
 *
 * Generates beautiful PDF export from selected items and answer bullets
 *
 * Request body:
 * {
 *   items: string[],              // Document IDs
 *   bullets: AnswerBullet[],      // Answer bullets with citations
 *   title?: string                // Optional custom title
 * }
 *
 * Response: PDF file (application/pdf)
 */
compose.post('/pdf', async (req, res, next) => {
  try {
    const body = req.body as Partial<ComposeRequest> & { title?: string };
    const rawItems = body?.items;
    const items = Array.isArray(rawItems)
      ? rawItems.filter((id): id is string => typeof id === 'string' && id.trim().length > 0)
      : typeof rawItems === 'string'
        ? [rawItems]
        : [];

    const rawBullets = body?.bullets;
    const bullets = Array.isArray(rawBullets)
      ? rawBullets.filter(
        (bullet): bullet is ComposeRequest['bullets'][number] =>
          Boolean(bullet && typeof bullet.text === 'string' && Array.isArray(bullet.cites))
      )
      : [];

    const customTitle = typeof body.title === 'string' ? body.title : undefined;

    if (items.length === 0 || bullets.length === 0) {
      return res.status(400).json({
        error: 'Missing required fields: items, bullets'
      });
    }

    // Generate PDF
    const pdfBuffer = await generatePDFBuffer(
      { bullets, items },
      {
        title: customTitle || 'CoST Knowledge Hub Export',
        includeAnswers: true,
        includeSources: true
      }
    );

    // Set response headers
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `CoST-Export-${timestamp}.pdf`;

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-Length', pdfBuffer.length);

    // Send PDF
    res.send(pdfBuffer);
  } catch (error) {
    next(error);
  }
});
